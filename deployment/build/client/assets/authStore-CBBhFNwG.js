import{c as b,d}from"./utils-Dmsv2dCC.js";function A(a,s){let e;try{e=a()}catch{return}return{getItem:t=>{var r;const l=h=>h===null?null:JSON.parse(h,void 0),u=(r=e.getItem(t))!=null?r:null;return u instanceof Promise?u.then(l):l(u)},setItem:(t,r)=>e.setItem(t,JSON.stringify(r,void 0)),removeItem:t=>e.removeItem(t)}}const w=a=>s=>{try{const e=a(s);return e instanceof Promise?e:{then(n){return w(n)(e)},catch(n){return this}}}catch(e){return{then(n){return this},catch(n){return w(n)(e)}}}},H=(a,s)=>(e,n,t)=>{let r={storage:A(()=>localStorage),partialize:o=>o,version:0,merge:(o,p)=>({...p,...o}),...s},l=!1;const u=new Set,h=new Set;let f=r.storage;if(!f)return a((...o)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),e(...o)},n,t);const y=()=>{const o=r.partialize({...n()});return f.setItem(r.name,{state:o,version:r.version})},P=t.setState;t.setState=(o,p)=>{P(o,p),y()};const g=a((...o)=>{e(...o),y()},n,t);t.getInitialState=()=>g;let m;const I=()=>{var o,p;if(!f)return;l=!1,u.forEach(i=>{var c;return i((c=n())!=null?c:g)});const v=((p=r.onRehydrateStorage)==null?void 0:p.call(r,(o=n())!=null?o:g))||void 0;return w(f.getItem.bind(f))(r.name).then(i=>{if(i)if(typeof i.version=="number"&&i.version!==r.version){if(r.migrate){const c=r.migrate(i.state,i.version);return c instanceof Promise?c.then(S=>[!0,S]):[!0,c]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,i.state];return[!1,void 0]}).then(i=>{var c;const[S,_]=i;if(m=r.merge(_,(c=n())!=null?c:g),e(m,!0),S)return y()}).then(()=>{v==null||v(m,void 0),m=n(),l=!0,h.forEach(i=>i(m))}).catch(i=>{v==null||v(void 0,i)})};return t.persist={setOptions:o=>{r={...r,...o},o.storage&&(f=o.storage)},clearStorage:()=>{f==null||f.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>I(),hasHydrated:()=>l,onHydrate:o=>(u.add(o),()=>{u.delete(o)}),onFinishHydration:o=>(h.add(o),()=>{h.delete(o)})},r.skipHydration||I(),m||g},O=H,R=b()(O((a,s)=>({user:null,profile:null,loading:!0,initialize:async()=>{try{const{data:{session:e}}=await d.auth.getSession();e!=null&&e.user&&(a({user:e.user}),await s().fetchProfile()),d.auth.onAuthStateChange(async(n,t)=>{t!=null&&t.user?(a({user:t.user}),await s().fetchProfile()):a({user:null,profile:null})})}catch(e){console.error("Auth initialization error:",e)}finally{a({loading:!1})}},signIn:async(e,n)=>{try{const{data:t,error:r}=await d.auth.signInWithPassword({email:e,password:n});return r?{error:r.message}:(a({user:t.user}),await s().fetchProfile(),{})}catch{return{error:"An unexpected error occurred"}}},signUp:async(e,n,t)=>{try{const{data:r,error:l}=await d.auth.signUp({email:e,password:n,options:{data:{full_name:t}}});if(l)return{error:l.message};if(r.user){const{error:u}=await d.from("profiles").insert({id:r.user.id,email:r.user.email,full_name:t,role:"user"});u&&console.error("Profile creation error:",u)}return{}}catch{return{error:"An unexpected error occurred"}}},signOut:async()=>{await d.auth.signOut(),a({user:null,profile:null})},fetchProfile:async()=>{const{user:e}=s();if(e)try{const{data:n,error:t}=await d.from("profiles").select("*").eq("id",e.id).single();if(t){console.error("Profile fetch error:",t);return}a({profile:n})}catch(n){console.error("Profile fetch error:",n)}},updateProfile:async e=>{const{user:n}=s();if(!n)return{error:"Not authenticated"};try{const{data:t,error:r}=await d.from("profiles").update(e).eq("id",n.id).select().single();return r?{error:r.message}:(a({profile:t}),{})}catch{return{error:"An unexpected error occurred"}}}}),{name:"auth-storage",partialize:a=>({user:a.user,profile:a.profile})}));export{O as p,R as u};
